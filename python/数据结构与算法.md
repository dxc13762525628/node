# 数据结构与算法

## 概述

### 问题求解与计算

> 数学模型

跨越自然语言的形式化系统

基于又穷观点的能行方法，有穷，能行

各种计算模型:递归函数论,Lambda演算,Post机

### 图灵计算机模型

> 一个图灵机

有规则的集合，机械，精确

> 通用图灵机

模拟任何一个图灵机的图灵机

### 算法计算复杂性

> 可计算

通过有限能行的方法进行计算

> 算法

用算术和逻辑运算的顺序，条件，循环组合流程解决

>计算复杂性

问题难以程度进行归类

> 不可计算

无法通过任何算法来计算

### 突破算法的局限

分布式智慧，超大规模并行计算，仿生计算

### 抽象与现实

>  抽象

抛弃底层实现的细节

> 实现

实现特定的技术

一个算法语言，需要提供基本的数据类型和控制流程语句

### 算法与程序

> 算法

更高效的利用计算资源和占用少的资源就是好算法

### 计算机资源指标

### timeit模块

```python
from timeit import Timer
# 表示让这个函数调用一千次去求平均值的时间
t1 = Timer("test01()",'from __main__ import test1')
print(t1.timeit(number=1000))
```

### python官网的算法复杂度

```python
https://wiki.python.org/moin/TimeComplexity3 

# 估算函数的大o数量级
big_o(func,xxx)
```

## Stack

先进后出

> 基本结构

```python
class Stack:
    """
    栈的基本结构
    """

    def __init__(self):
        self.stack = []

    def is_empty(self):
        """
        判断是否为空
        :return:
        """
        return True if not self.stack else False

    def push(self, item):
        """
        压入栈
        :param item: 数据
        :return:
        """
        self.stack.append(item)

    def pop(self):
        """
        弹出栈
        :return:
        """
        return self.stack.pop()
    
    def size(self):
        """
        求栈的大小
        """
        return len(self.stack)
```

> 括号匹配

```python
"""
括号匹配
"""
from data_alt.stack_demo01 import Stack


class MatchParentheses:
    """
    括号匹配
    """

    def __init__(self, input_str):
        """
        初始化
        :param input_str: 输入字符串
        """
        self.stack = Stack()
        self.input_str = input_str
        self.match_str = {
            ")": "(",
            "]": "[",
            "}": "{"
        }

    def check_parentheses(self):
        """
        校验是否匹配
        :return:
        """
        for i in self.input_str:
            if i in self.match_str.values():
                self.stack.push(i)
            elif i in self.match_str.keys():
                if self.stack.is_empty():
                    return False
                elif self.stack.pop() != self.match_str[i]:
                    return False
            else:
                continue
        if not self.stack.is_empty():
            return False
        return True
```

> 10进制转2进制

```python
class TenToTwo:
    """
    10进制转2进制
    """

    def __init__(self, number, ):
        self.number = number
        self.stack = Stack()

    def number_transform(self):
        """
        进制转换
        :return:
        """
        while self.number > 0:
            self.stack.push(self.number % 2)
            self.number //= 2

        target = []
        while not self.stack.is_empty():
            target.append(str(self.stack.pop()))
        return "".join(target)
```

## Queue

先进先出

> 基本结构



```python
class Queue:
    """
    队列的抽象数据结构
    """

    def __init__(self):
        """
        数据初始化
        """
        self.queue = []

    def enqueue(self, item):
        """
        入队
        :param item:
        :return:
        """
        self.queue.append(item)

    def dequeue(self):
        """
        出队
        :return:
        """
        return self.queue.pop(0)

    def is_empty(self):
        """
        判断队列是否为空
        :return:
        """
        return self.queue == []

    def size(self):
        """
        求出队列大小
        :return:
        """
        return len(self.queue)
```

> 热土豆问题



```python
class HotPotato:
    """
    热土豆问题
    """

    def __init__(self, num, persons):
        """
        数据初始化
        :param num:土豆数量
        :param persons: 人数
        """
        self.queue = Queue()
        self.num = num
        for person in persons:
            self.queue.enqueue(person)

    def handle_person(self):
        """
        处理土豆问题
        :return:
        """
        while self.queue.size() > 1:
            for i in range(self.num):
                self.queue.enqueue(self.queue.dequeue())
            self.queue.dequeue()
        return self.queue.dequeue()
```

> 双端队列

首尾都可以进或者出

```python
class Deque:
    """
    双端队列
    """

    def __init__(self):
        """
        初始化一个队列
        """
        self.deque = []

    def add_front(self, item):
        """
        队列首加数据
        :param item:
        :return:
        """
        self.deque.insert(0, item)

    def add_rear(self, item):
        """
        队列尾端加数据
        :param item:
        :return:
        """
        self.deque.append(item)

    def remove_font(self):
        """
        从队列首端删除数据
        :return:
        """
        return self.deque.pop(0)

    def remove_rear(self):
        """
        从队列尾端删除数据
        :return:
        """
        return self.deque.pop()

    def size(self):
        """
        求出队列大小
        :return:
        """
        return len(self.deque)

    def is_empty(self):
        """
        判断队列是否为空
        :return:
        """
        return self.deque == []
```



> 回文字

```python
class BackText:
    """
    回文字
    """

    def __init__(self, target_text):
        """
        初始化队列
        """
        self.target_text = target_text
        self.deque = Deque()

    def check_text(self):
        """
        校验文本
        :return:
        """
        for ch in self.target_text:
            self.deque.add_rear(ch)

        while self.deque.size() > 1:
            first = self.deque.remove_font()
            last = self.deque.remove_rear()
            if first != last:
                return False
        return True
```

## Link

链表

> 基本结构



```python
class LinkNode:
    """
    链表结构
    """

    def __init__(self, data):
        """
        初始化数据
        :param data:
        """
        self.data = data
        self.next = None

    def get_data(self):
        """
        获取数据
        :return:
        """
        return self.data

    def get_next(self):
        """
        获取下一个节点
        :return:
        """
        return self.next

    def set_data(self, data):
        """
        给节点赋值
        :param data:
        :return:
        """
        self.data = data

    def set_next(self, next):
        """
        链接一个节点
        :param next:
        :return:
        """
        self.next = next
```



## 魔法方法

### 字符串打印

> ### __str__



> ### __repr__





